[After dropping idea of header gadget positioned using Blogger Layout ...]

Some additional possiblities: 1) Have a Blogger menu item entry that triggers action like button click. This menu item will always be accessible on all device breakpoints (window widths). 2) Have icon button at bottom right for all breakpoints. But we will provide user the option to hide this button. 3) When user clicks menu item entry or floating icon-button, the dialog should have: a) Message that dark-mode feature for this blog has some issues due to Blogger constraints. b) Radio button for Enable/Disable system dark-mode support c) Radio button to show/hide icon button. d) OK/Cancel buttons. 4) The default value for show/hide icon button should be hide for upto mobile breakpoint and show for above mobile breakpoint What do u think?

Yes, Ravi ‚Äî that design makes a lot of sense. It‚Äôs a flexible, user-friendly approach that addresses all the constraints we‚Äôve discussed. Let me break it down:

‚úÖ Key points about your proposed approach

Menu item always accessible

Guarantees that all users, desktop or mobile, can open the dark-mode dialog.

Serves as the primary control, independent of floating button visibility.

Floating icon button at bottom-right

Works as a shortcut for larger screens, but can be hidden on mobile to avoid covering content.

Allowing the user to toggle visibility gives full flexibility without forcing one layout on everyone.

Dialog with options

Message: Explains limitations due to Blogger ‚Äî sets expectations and avoids confusion.

Enable/Disable system dark-mode support: Controls the dark mode itself.

Show/Hide icon button: Gives control over floating button visibility, useful for mobile users.

OK/Cancel buttons: OK saves settings to localStorage; Cancel simply closes dialog without changes.

Default values

Icon button hidden on mobile (small viewports).

Icon button shown on desktop/larger screens.

This balances visibility vs. content obstruction.

üîπ Advantages

Works across all devices without complex theme HTML edits.

Users can personalize their experience (hide the button if they want).

Simplifies mobile experience while keeping desktop convenience.

Only one dialog and JS logic is needed ‚Äî maintainable and scalable.

üîπ Implementation outline

Menu item triggers a JS function: opens the modal dialog.

Floating icon button triggers the same function.

Modal dialog contains:

Message

Two sets of radio buttons (Enable/Disable dark-mode, Show/Hide icon)

OK/Cancel buttons

Settings stored in localStorage (dark-mode opt-in, icon visibility).

CSS media queries control default icon visibility per breakpoint.

If you like, I can create a ready-to-drop-in HTML/JS/CSS snippet for your Blogger blog that implements exactly this approach, including:

Menu item integration

Bottom-right floating button with default breakpoint-based visibility

Dialog with message + two radio groups + OK/Cancel

Persistent settings via localStorage

Do you want me to prepare that?



1Ô∏è‚É£ Add this to an HTML/JS Gadget (anywhere in your layout)

<!-- Dark Mode Control Gadget -->
<div id="darkModeGadget"></div>

<style>
/* Floating icon button */
#themePromptBtn {
  position: fixed;
  bottom: 12px;
  right: 12px;
  z-index: 9999;
  background: #444;
  color: white;
  border: none;
  border-radius: 6px;
  padding: 6px 10px;
  cursor: pointer;
  font-size: 18px;
  display: none; /* default hidden, JS will control */
}

/* Modal overlay */
#themeModalOverlay {
  display: none;
  position: fixed;
  top:0; left:0; right:0; bottom:0;
  background: rgba(0,0,0,0.5);
  z-index: 10000;
}

/* Modal box */
#themeModal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  color: black;
  padding: 20px;
  border-radius: 8px;
  width: 300px;
  max-width: 90%;
}

/* Modal buttons */
#themeModal button {
  margin: 6px 6px 0 0;
  padding: 6px 10px;
  cursor: pointer;
}

</style>

<!-- Floating button -->
<button id="themePromptBtn">üåì</button>

<!-- Modal -->
<div id="themeModalOverlay">
  <div id="themeModal">
    <p>Dark-mode feature for this blog has some limitations due to Blogger constraints.</p>
    <form>
      <p><strong>System Dark Mode Support:</strong></p>
      <input type="radio" name="darkMode" value="enable" id="dmEnable" /><label for="dmEnable">Enable</label><br />
      <input type="radio" name="darkMode" value="disable" id="dmDisable" /><label for="dmDisable">Disable</label><br /><br />

      <p><strong>Show Icon Button:</strong></p>
      <input type="radio" name="iconBtn" value="show" id="iconShow" /><label for="iconShow">Show</label><br />
      <input type="radio" name="iconBtn" value="hide" id="iconHide" /><label for="iconHide">Hide</label><br /><br />

      <button type="button" id="modalOK">OK</button>
      <button type="button" id="modalCancel">Cancel</button>
    </form>
  </div>
</div>

<script>
// Default breakpoint for showing floating icon button
const iconBreakpoint = 800;

// Initialize settings from localStorage
let darkModeEnabled = localStorage.getItem('darkModeEnabled') === 'true';
let iconBtnVisible = localStorage.getItem('iconBtnVisible');

// Determine initial icon visibility based on window width
function updateIconVisibility() {
  const btn = document.getElementById('themePromptBtn');
  const w = window.innerWidth;
  if (iconBtnVisible === 'show' || (iconBtnVisible === null && w >= iconBreakpoint)) {
    btn.style.display = 'block';
  } else {
    btn.style.display = 'none';
  }
}

// Apply dark mode if enabled
function applyDarkMode() {
  const body = document.body;
  if (darkModeEnabled) {
    body.classList.add('darkmode-optin');
  } else {
    body.classList.remove('darkmode-optin');
  }
}

// Show modal and set radio buttons according to current settings
function openModal() {
  document.getElementById('themeModalOverlay').style.display = 'block';
  document.getElementById(darkModeEnabled ? 'dmEnable' : 'dmDisable').checked = true;
  const w = window.innerWidth;
  const showDefault = iconBtnVisible === 'show' || (iconBtnVisible === null && w >= iconBreakpoint);
  document.getElementById(showDefault ? 'iconShow' : 'iconHide').checked = true;
}

// Hide modal
function closeModal() {
  document.getElementById('themeModalOverlay').style.display = 'none';
}

// OK button handler
document.getElementById('modalOK').onclick = function() {
  darkModeEnabled = document.querySelector('input[name="darkMode"]:checked').value === 'enable';
  iconBtnVisible = document.querySelector('input[name="iconBtn"]:checked').value;

  localStorage.setItem('darkModeEnabled', darkModeEnabled);
  localStorage.setItem('iconBtnVisible', iconBtnVisible);

  applyDarkMode();
  updateIconVisibility();
  closeModal();
};

// Cancel button handler
document.getElementById('modalCancel').onclick = closeModal;

// Floating button click opens modal
document.getElementById('themePromptBtn').onclick = openModal;

// You can also link a menu item to call openModal() for all breakpoints
// Example: <a href="javascript:openModal()">Dark Mode</a>

// Initialize on page load
window.addEventListener('load', () => {
  applyDarkMode();
  updateIconVisibility();
});

// Update icon visibility on window resize
window.addEventListener('resize', updateIconVisibility);
</script>


....


Absolutely, Ravi. Here‚Äôs a practical way to add a Blogger menu item that calls a JavaScript function like openModal() (the one that opens your dark-mode dialog).

1Ô∏è‚É£ Identify the menu you want to add the item to

Go to Blogger ‚Üí Layout ‚Üí Pages / Menu (depending on how you‚Äôve set up your top navigation).

Usually, menu items are static pages or custom links.

2Ô∏è‚É£ Add a Custom Link menu item

In the Pages / Menu widget, choose Add external link (or ‚ÄúAdd Link‚Äù).

Set:

Name: e.g., Dark Mode

URL: javascript:openModal()

Example:

Link Name: Dark Mode
URL: javascript:openModal()


Save the menu.

3Ô∏è‚É£ Notes / Tips

The javascript: URL scheme tells the browser to execute the function instead of navigating to a URL.

Make sure your HTML/JS gadget with the openModal() function is already loaded on the page (usually via a gadget placed in the layout or inside the theme).

Test by clicking the new menu item ‚Äî it should open the dialog just like the floating button.



================


So the part of reading the system light/dark mode setting is not working correctly.

I think I got the issue. The Css is as follows:
/* Default light mode (Contempo Light normal colors) */
body {
  background-color: white;
  color: black;
}

/* System dark-mode rules, only active when user has opted in */
.darkmode-optin {
  color-scheme: dark;
}

.darkmode-optin .post-body {
  background-color: black !important;
  color: white !important;
}

.darkmode-optin a {
  color: #bb86fc !important;
}

.darkmode-optin blockquote {
  background-color: #222 !important;
  color: #e0e0e0 !important;
}

===================

The darkmode-optin class setting in JS code only reflects whether user has opted to use dark/light mode system setting. It does not mean dark mode should be shown always.

/* System dark-mode rules, only active when user has opted in */
.darkmode-optin {
  color-scheme: dark;
}

@media (prefers-color-scheme: dark) {
  body, .post-outer, .post-outer-container, .post-title, .post-header, .post-header-line-1, .published, .post-body, .comment-form {
    background-color: black !important;
    color: white !important;
  }
}


============================

With the above, on change of chrome setting from dark to light and back, when darkmode-optin is true works.
But even when darkmode-optin is false, it switches btw light and dark when chrome settings change btw light and dark

Another issue is that the icon button is shown at bottom right only from close to maximized window!

Noticed that the button shows only when left side menu is shown!
================

position fixed trial that works:
https://playcode.io/css
body {
  background: #6e28d9;
  padding: 0 24px;
  color: rgb(226, 48, 48); /* Change my color to yellow */
  margin: 0;
  height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
}
.test {position: fixed;
bottom: 20px;
right: 40px; }

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="src/style.css">
  </head>
  <body>
   
    <h1 class='test'>Hi friend, try change my color!</h1>

  </body>
</html>
==============

https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme


------------------------------------
google search ai: css apply dark mode if class x is defined
CSS
Your standard (light) theme styles are declared normally. Then, add a new set of rules prefixed with the .dark-mode selector to define the dark theme. 
css
/* Default (Light Mode) styles */
body {
  background-color: #ffffff;
  color: #333333;
}
.card {
  background-color: #f0f0f0;
  border: 1px solid #ccc;
}

/* Dark Mode styles (applied when .dark-mode class is present on the body) */
body.dark-mode {
  background-color: #121212;
  color: #e0e0e0;
}
.dark-mode .card {
  background-color: #1e1e1e;
  border: 1px solid #333;
}
==========================

Trial with test CSS in blog:
/* System dark-mode rules, only active when user has opted in */


@media (prefers-color-scheme: dark) {
  body.darkmode-optin, .post-outer.darkmode-optin, .post-outer-container.darkmode-optin, .post-title.darkmode-optin, .post-header.darkmode-optin, .post-header-line-1.darkmode-optin, .published.darkmode-optin, .post-body.darkmode-optin, .comment-form {
    background-color: black !important;
    color: white !important;
  }
}

----------
